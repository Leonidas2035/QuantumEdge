===FILE: Documentation/Audit_ai_scalper_bot.txt===

Огляд проєкту (Overview)
Поточний стан: каркас паперового трейдера з мок-стрімом (bot/run_bot.py) та мінімальною ML-енсембл-логікою (bot/ml/ensemble.py). Бойової інтеграції з біржею немає, більшість модулів трейдингу/ризиків – заглушки.
Основні проблеми:
У репозиторії збережені продакшн-ключі Binance/OpenAI (config/secrets.env) у відкритому вигляді.
Відсутня реальна торгівля й ризик-контроль: працює лише PaperTrader, модулі executor.py, order_manager.py, risk_engine.py, position_manager.py порожні.
Дані/моделі не узгоджені між онлайн і офлайн контурами; збереження тіку в окремий JSON на кожен трейд спричинить лавинне засмічення диску.
Рекомендації:
Негайно відкликати ключі, видалити їх із репозиторію, перейти на .env поза VCS.
Чітко розділити бойовий трейдинг і збір даних; додати повноцінний виконуючий клієнт з валідаціями та ризиками.
Уніфікувати конвеєр даних/фіч онлайн vs офлайн, відмовитись від пер-трейд JSON.
Архітектура та основні компоненти
Як працює: конфіг завантажується в bot/core/config_loader.py при імпорті; стрім подій генерує bot/market_data/mock_ws_manager.py; фічі збирає bot/ml/signal_model/online_features.py; рішення — bot/engine/decision_engine.py; виконання — bot/trading/paper_trader.py; зберігання — bot/market_data/data_manager.py.
Проблеми:
Багато модулів-пустишок (bot/trading/*.py, bot/ai_llm/*.py, bot/backtester/*.py, bot/market_data/binance_ws.py, bot/market_data/bingx_ws.py), що створює хибне відчуття покриття.
Тісне зчеплення: config_loader читає файл та secrets на імпорті без обробки помилок; немає DI/інтерфейсів для джерел даних чи брокера.
run_bot.py завжди використовує мок-WS навіть якщо конфіг каже інше.
Рекомендації:
Ввести чіткі інтерфейси: IDataStream, IExecutor, IRiskEngine; розділити прод/папір/бектест.
Ледачий/відкладений лоад конфігів + валідація схеми.
Прибрати/реалізувати заглушки або явно виключити їх зі збірки.
Трейдинговий двигун та ризик-менеджмент
Як працює: DecisionEngine вирішує buy/sell/close/hold за порогами й фіксованим розміром позиції (max_risk_per_trade * leverage), без стопів і TP. PaperTrader веде PnL локально.
Проблеми:
Немає стоп-лоса/тейк-профіту/трейлінгу; розмір позиції не прив’язаний до балансу, маржі чи мін. кроків біржі (bot/engine/decision_engine.py).
Немає контролю експозиції/денної втрати/торгових лімітів, попри параметри в config/settings.yaml.
Немає перевірок дублювання/стану ордерів; при переході на реального брокера можливі подвійні входи/залипання.
PaperTrader спрощує PnL і не моделює проскальзування/маржу/ліквідацію.
Рекомендації:
Додати ризик-двигун: ліміти за денним PnL, макс. відкриті ордери, блокування при помилках, примусовий close при втраті зв’язку.
Розмір позиції = f(баланс, плечі, min_notional, min_qty, step_size) з валідацією перед надсиланням.
Реалізувати SL/TP/брейк-івени/трейлінг, контроль дублікатів ордерів і ідемпотентність.
Для паперових тестів – реалістичне моделювання комісій і спреду.
Дані, маркет-дата і консистентність офлайн/онлайн
Як працює: онлайн фічі з 10 останніх тіку (online_features.py), модель очікує порядок FEATURE_COLS з dataset_builder.py. Дані пишуться у CSV data/ticks/*_stream.csv та JSON на кожен трейд (data_manager.py). Офлайн симуляція з sandbox/offline_loop.py.
Проблеми:
Відсутність єдиного сховища: онлайн пише в config.app.data_path, офлайн тренування читає з жорсткого storage/data/ticks (dataset_builder.py) — високий ризик різних датасетів.
Збереження кожного тіку у окремий JSON (_save_json) → неконтрольований ріст файлової системи і затримки в гарячому циклі.
OfflineSimulator пише в data/trades/data/orderbooks, але DatasetBuilder читає data/ticks → тренування і симуляції розходяться.
Валідація подій мінімальна; некоректний payload може silently пропускатися, залишаючи прогалини.
Рекомендації:
Єдине джерело правди для тіку (партиціоновані Parquet/Feather), ротація/архівація.
Винести персистенцію із гарячого циклу в окремий воркер/чергу.
Уніфікувати шляхи (посилання на config.app.data_path) для усіх компонентів; додати схемну валідацію вхідних подій.
Для офлайн/онлайн – один і той самий builder з однаковими нормалізаціями й лагами.
ML / AI / LLM шар
Як працює: XGBoost бінарник (signal_model/model.py), фічі прості ретерни/обсяги; ансамбль фіксованих ваг (ml/ensemble.py). LLM-модератор — детерміністичний хардкод без виклику API (ai/risk_moderator.py).
Проблеми:
Тренування (signal_model/train.py) без валідації/сплітів/метрик; можливий total data leakage та переобучення.
Відсутня калібровка й контроль дрейфу; моделі завантажуються з диску без версій/підписів.
filter_blocks блокує при ret_1>0.01/низькій волатильності — жорсткі магічні константи без адаптації до режиму ринку.
LLM-поділ не робить фактичного запиту; немає sandboxing/списків дозволених дій, тож реальний LLM може вигадати некоректні інструкції.
Рекомендації:
Додати train/val/test split, крос-валідацію, метрики (precision/recall, MCC), логування метаінфо моделі.
Зберігати моделі з versioning + hash; робити контроль сумісності фічей (schema hash).
Перенести пороги/фільтри в конфіг і робити адаптацію на основі волатильності/спреду.
Для LLM — строгий JSON-шаблон, whitelist відповідей, ліміти на довжину; виклик через ізольований сервіс із rate-limit і audit log.
Інтеграція з біржею та зовнішніми API
Як працює: ws_manager.py вміє слухати Binance public WS і писати дані; торгівельного клієнта немає. LLM/API — ключі зчитуються через .env.
Проблеми:
Відсутній виконуючий клієнт (REST/WS ордери), немає retry/backoff/timeout/rate-limit.
Немає нормалізації/округлення цін і кількостей під специфікації біржі; ризик reject/некоректних ордерів.
Відсутні коди помилок/handling (insufficient margin, unknown order, cancel reject).
Рекомендації:
Реалізувати біржовий клієнт з явним rate limit, тайм-аутами, ідемпотентними ключами ордерів, перевіркою мін/кроків.
Додати шар адаптерів під біржі (spot/futures) і контракти (ліміт/маркет/лівередж).
Центральний обробник помилок з класифікацією (мережа/біржа/логіка) й політикою повторів.
Конфігурація, секрети та безпека
Як працює: config_loader.py читає config/settings.yaml, одразу завантажує config/secrets.env у середовище.
Проблеми:
Секрети в репозиторії (config/secrets.env) — критична вразливість.
Конфіг читається на імпорті без try/except — будь-яка помилка YAML падає всю програму.
Скрипти встановлення виконують ExecutionPolicy Bypass, що підвищує ризик зловмисного коду.
Логування чутливих даних не відфільтроване; дані WS пишуться у відкритий CSV/JSON без шифрування.
Рекомендації:
Видалити секрети з VCS, перевипустити ключі, перейти на менеджер секретів/CI variable store.
Додати валідацію/дефолти/обгортку помилок при завантаженні конфіга; схему (pydantic/cerberus).
Мінімізувати права скриптів, прибрати Bypass, перевіряти хеші скачуваних інсталяторів.
Обмежити логування персональних даних, додати редакцію ключів.
Надійність, обробка помилок, логування та моніторинг
Як працює: Основний цикл у bot/run_bot.py має локальний try для парсингу події; решта викликів можуть кинути виняток і зупинити цикл. Логування — print.
Проблеми:
Немає централізованого exception-handler, watchdog чи graceful shutdown; падіння будь-якого компонента зупинить бота.
Відсутні health-checks, алерти, метрики; немає ротації логів.
Затримки через sync I/O (запис файлів) у гарячому циклі можуть викликати лаги/бекпрешер.
Рекомендації:
Обгорнути основний цикл у захищений runner з retry і бек-оффом; окремі таски для IO/ML/exec з тайм-аутами.
Ввести structured logging (JSON), метрики (Prometheus/OpenTelemetry), ліміти на розмір файлів.
Перенести персистенцію у фоновий воркер/чергу, додати профілювання затримок.
Продуктивність і масштабування
Як працює: Один поток подій, послідовні операції запису/ML/трейдингу; XGBoost predict_proba викликається на кожен тик.
Проблеми:
Пер-трейд дисковий запис (JSON + append CSV) — головне вузьке місце і потенційний стоп.
Відсутня асинхронізація/батчинг/пайплайнінг; все виконується в одному loop.
Немає warmup/кешів для моделі; завантаження моделі на імпорт може блокувати старт без контролю.
Рекомендації:
Кешувати модель один раз, робити батчеву обробку або throttling тіку, винести IO в окремий процес/чергу.
Додати профайлинг latency, оптимізувати фічі (векторизація, уникати зайвих конверсій).
Використати ring-buffers і попередньо аллоковані структури для HFT-навантаження.
Основні ризики та недоліки
Витік секретів (config/secrets.env) → компрометація біржових акаунтів та OpenAI billing.
Відсутність виконуючого та ризик-двигуна → при переході на реальні ордери неминучі фінансові втрати (немає SL/TP/валідацій).
Невідповідність даних/фіч онлайн vs офлайн → моделі можуть поводитись непередбачувано на реальному стрімі.
Дискові операції у гарячому циклі → ризик зависання/лагів і втрати синхронізації.
Відсутність моніторингу/health-checks → бот може тихо зупинитися або зависнути без сповіщення.
Пріоритетні рекомендації
High:
Прибрати секрети з репо, перевипустити ключі, перейти на захищене сховище.
Реалізувати мінімально життєздатний Risk/Execution engine (SL/TP, ліміти експозиції, валідація параметрів ордерів, ідемпотентність).
Вирівняти конвеєр даних (єдиний шлях/формат, ротація, асинхронний writer) та відключити пер-трейд JSON.
Додати централізований error-handling, structured logging, базові алерти.
Medium:
Уточнити фільтри/пороги в конфігах, адаптивні до волатильності; розширити PaperTrader моделюванням спреду/маржі.
Запровадити train/val/test спліти, метрики й версіонування моделей; schema-hash фічей.
Додати реальний data stream від біржі (WS + REST sync), handle reconnect/backoff/rate-limit.
Low:
Покращити інсталятори (перевірка хешів, мінімізація прав, чисті повідомлення).
Автоматизувати тести (unit для фіч/рішень, інтеграційні для data loop).
Документація по архітектурі/контрактам інтерфейсів.
Швидкий чек-лист перших кроків (Quick Wins)
Видалити config/secrets.env з репозиторію, відкликати ключі, перейти на .env.local поза VCS.
Вимкнути пер-трейд JSON у bot/market_data/data_manager.py або обмежити ротацією; писати батчами у Parquet.
Примусово використовувати реальний WS у _event_stream (bot/run_bot.py) за конфігом, додати fallback із явним прапорцем.
Додати хоча б статичні SL/TP і обмеження експозиції в DecisionEngine/PaperTrader.
Уніфікувати шляхи даних: використовувати config.app.data_path у DatasetBuilder та офлайн-скриптах.
Обгорнути головний цикл у захищений runner з тайм-аутами/логуванням винятків.
Додати базові метрики/логи (PnL, позиція, затримка) у структурованому форматі.
Створити простий train/validation split і звіт по метриках перед деплоєм моделі.
Перевірити та прибрати зайві заглушки/порожні файли, щоб уникнути помилкових припущень про готовність компонентів.